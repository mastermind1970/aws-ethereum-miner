# ============================= #
# !!! Do NOT edit this file !!! #
# ============================= #
# Instead edit template-eth-default-vpc.template.yml and run 'import-files.py' again

# Use this template if you wish to stand up the instances in the "Default VPC"

AWSTemplateFormatVersion: '2010-09-09'

Metadata:
  RepoUrl: https://github.com/mludvig/aws-ethereum-miner
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Miner Configuration
        Parameters:
        - EthWallet
        - Hashrate

      - Label:
          default: Instance Configuration
        Parameters:
        - InstanceTypes
        - PricingPlan

Parameters:
  InstanceTypes:
    Description: |
      Instance types to choose from. Can be "*" to use all available, or wildcards e.g. "g4dn.*,g5.*",
      or a list of specific instances e.g. "p3.2xlarge,p3.8xlarge". The most cost effective combination
      of available instances will be used.
    Type: String
    Default: "*"

  Hashrate:
    Description: |
      Required hashrate in MH/s. AWS will start the most cost effective available
      instances to achieve this Hashrate. Minimum is 25 (1x g4dn.xlarge).
    Type: Number
    Default: 250
    MinValue: 25

  FluxWallet:
    Type: String
    Description: Flux Wallet Address
    Default: "t1S5sPiGb2bJjZM6r1pXhToCqCmfZ3pPvPn.big5"

  PricingPlan:
    Type: String
    Description: Spot or On-Demand or Both
    AllowedValues:
    - spot
    - ondemand
    - both
    Default: both

Mappings:
  # ImageId of "cuda-11 2021-11-19T06-45-18.713Z" in each region
  RegionMap:
    ap-northeast-1:
      ImageId: ami-057223d0b465ef6c8
    ap-northeast-2:
      ImageId: ami-04974804b5c32ad3f
    ap-south-1:
      ImageId: ami-0138f84dea0009e24
    ap-southeast-1:
      ImageId: ami-028fec8125dca56aa
    ap-southeast-2:
      ImageId: ami-07b457617d5ab5026
    ca-central-1:
      ImageId: ami-00cbba349f2627bef
    eu-central-1:
      ImageId: ami-0527e1e1ca0929e8c
    eu-north-1:
      ImageId: ami-070fab14d346eec81
    eu-west-1:
      ImageId: ami-052dfb972e5a6cdd0
    eu-west-2:
      ImageId: ami-0126c804cd6d92090
    eu-west-3:
      ImageId: ami-0fe47281cdcb0102b
    sa-east-1:
      ImageId: ami-0ad6f33841de28c4c
    us-east-1:
      ImageId: ami-04822dc0e04836a86
    us-east-2:
      ImageId: ami-0b3cc42a259739f29
    us-west-1:
      ImageId: ami-00158baf36cd6ace7
    us-west-2:
      ImageId: ami-013f60ec8ba5a9ca4


  CapacityAllocation:
    spot:
      OnDemandPct: "0"
    both:
      OnDemandPct: "50"
    ondemand:
      OnDemandPct: "100"

Resources:
  InstanceFilter:
    Type: Custom::InstanceFilter
    Properties:
      ServiceToken: !GetAtt InstanceFilterLambda.Arn
      InstanceTypesWanted: !Ref InstanceTypes
      InstanceTypesAttributes:
      # WeightedCapacity is the instance type Hashrate in MH/s
      - InstanceType: g5.xlarge
        WeightedCapacity: "56"
      - InstanceType: g5.24xlarge
        WeightedCapacity: "226"
      - InstanceType: g5.48xlarge
        WeightedCapacity: "452"
      - InstanceType: g4dn.xlarge
        WeightedCapacity: "25"
      - InstanceType: g4dn.2xlarge
        WeightedCapacity: "25"
      - InstanceType: g4dn.12xlarge
        WeightedCapacity: "100"
      - InstanceType: g4dn.metal
        WeightedCapacity: "204"
      - InstanceType: p3.2xlarge
        WeightedCapacity: "93"
      - InstanceType: p3.8xlarge
        WeightedCapacity: "372"
      - InstanceType: p3.16xlarge
        WeightedCapacity: "744"
      - InstanceType: p3dn.24xlarge
        WeightedCapacity: "692"
      ## p4d.24xlarge doesn't work with ethminer
      #- InstanceType: p4d.24xlarge
      #  WeightedCapacity: "999" # It's in fact ~1400 but the max value allowed here is 999

  InstanceFilterLambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        # Lambda source is in src/lambdas/instance-filter.py
        ZipFile: |
          #!/usr/bin/env python3
          import json
          import urllib3
          import datetime
          import boto3
          http=urllib3.PoolManager()
          ec2=boto3.client("ec2")
          SUCCESS="SUCCESS"
          FAILED="FAILED"
          def send(event,context,status,data={},reason=None):
           responseUrl=event["ResponseURL"]
           responseBody={"Status":status,"PhysicalResourceId":context.log_stream_name,"StackId":event["StackId"],"RequestId":event["RequestId"],"LogicalResourceId":event["LogicalResourceId"],"Reason":reason or "See the details in CloudWatch Log Stream: {}".format(context.log_stream_name),}
           if data:
            responseBody["Data"]=data
           json_responseBody=json.dumps(responseBody)
           print("== RESPONSE ==")
           print(json_responseBody)
           headers={"content-type":"","content-length":str(len(json_responseBody))}
           try:
            response=http.request("PUT",responseUrl,headers=headers,body=json_responseBody)
            print("Status code:",response.status)
           except Exception as e:
            print("send(..) failed executing http.request(..):",e)
          def filter_wanted(types,wanted):
           if wanted=="*":
            print(f"Instance types wanted: * (=any)")
            return True,types
           wanted_types=list(map(lambda x:x.strip().rstrip("*").lower(),wanted.split(",")))
           wanted_types=list(map(lambda x:x if x.find(".")>=0 else f"{x}.",wanted_types))
           print(f"Instance types wanted: {' '.join(wanted_types)}")
           filtered_types=[]
           for wt in wanted_types:
            filtered_types.extend(list(filter(lambda x:x.startswith(wt),types)))
           filtered_types=list(set(filtered_types)) 
           if not filtered_types:
            return False,"No wanted instance types match the available types."
           print(f"Instance types filtered: {' '.join(filtered_types)}")
           return True,filtered_types
          def filter_available(types):
           result=ec2.describe_instance_type_offerings(LocationType="region",Filters=[{"Name":"instance-type","Values":types}])
           types_available=list(map(lambda x:x["InstanceType"],result["InstanceTypeOfferings"]))
           print(f"Instance types available in this region: {' '.join(types_available)}")
           return True,types_available
          def sort_by_efficiency(attrs):
           data={t["InstanceType"]:t for t in attrs}
           result=ec2.describe_spot_price_history(InstanceTypes=list(data.keys()),ProductDescriptions=["Linux/UNIX"],StartTime=datetime.datetime.now()-datetime.timedelta(minutes=1),)
           for r in result["SpotPriceHistory"]:
            t=r["InstanceType"]
            if "_count" not in data[t]:
             data[t]["_count"]=0
             data[t]["_sum"]=0.0
            data[t]["_count"]+=1
            data[t]["_sum"]+=float(r["SpotPrice"])
           for t in data.keys():
            data[t]["_spot"]=data[t]["_sum"]/data[t]["_count"]
            data[t]["_efficiency"]=(float(data[t].get("WeightedCapacity",1))/data[t]["_spot"])
            del data[t]["_sum"]
            del data[t]["_count"]
           attrs=list(data.values())
           attrs.sort(key=lambda x:(-x["_efficiency"],x["_spot"]))
           print(f"Instances sorted: {json.dumps(attrs)}")
           for a in attrs:
            for key in list(a.keys()):
             if key.startswith("_"):
              del a[key]
           return attrs
          def lambda_handler(event,context):
           print("== EVENT ==")
           print(json.dumps(event))
           try:
            try:
             attrs=event["ResourceProperties"]["InstanceTypesAttributes"]
             wanted=event["ResourceProperties"]["InstanceTypesWanted"]
            except KeyError as e:
             raise Exception("Missing required property: {e}")
            try:
             types=list(map(lambda x:x["InstanceType"],attrs))
            except KeyError as e:
             raise Exception("'InstanceTypesAttributes' must be a list where each item must have an 'InstanceType' attribute")
            success,types_wanted=filter_wanted(types,wanted)
            if not success:
             raise Exception(types_wanted)
            success,types_available=filter_available(types_wanted)
            if not success:
             raise Exception(types_available)
            attrs=list(filter(lambda x:x["InstanceType"]in types_available,attrs))
            if not attrs:
             raise Exception("None of the requested instance types is available in this region!")
            attrs=sort_by_efficiency(attrs)
            types_sorted=list(map(lambda x:x["InstanceType"],attrs))
           except Exception as e:
            send(event,context,FAILED,reason=f"Error: {e}")
            return False
           send(event,context,SUCCESS,{"InstanceTypeNames":" ".join(types_sorted),"InstanceTypeAttributes":attrs,},)
          # Created by pyminifier (https://github.com/liftoff/pyminifier)
          
      Handler: "index.lambda_handler"
      Runtime: python3.9
      Timeout: 10
      Role: !GetAtt LambdaExecutionRole.Arn

  AsgUpdater:
    DependsOn:
    - Asg
    Type: Custom::AsgUpdater
    Properties:
      ServiceToken: !GetAtt AsgUpdaterLambda.Arn
      AsgName: !Ref Asg
      DesiredCapacity: !Ref Hashrate

  AsgUpdaterLambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        # Lambda source is in src/lambdas/asg-updater.py
        ZipFile: |
          #!/usr/bin/env python3
          import json
          import boto3
          import urllib3
          http=urllib3.PoolManager()
          asg=boto3.client("autoscaling")
          SUCCESS="SUCCESS"
          FAILED="FAILED"
          def send(event,context,status,data={},reason=None):
           responseUrl=event["ResponseURL"]
           responseBody={"Status":status,"PhysicalResourceId":context.log_stream_name,"StackId":event["StackId"],"RequestId":event["RequestId"],"LogicalResourceId":event["LogicalResourceId"],"Reason":reason or "See the details in CloudWatch Log Stream: {}".format(context.log_stream_name),}
           if data:
            responseBody["Data"]=data
           json_responseBody=json.dumps(responseBody)
           print("== RESPONSE ==")
           print(json_responseBody)
           headers={"content-type":"","content-length":str(len(json_responseBody))}
           try:
            response=http.request("PUT",responseUrl,headers=headers,body=json_responseBody)
            print("Status code:",response.status)
           except Exception as e:
            print("send(..) failed executing http.request(..):",e)
          def lambda_handler(event,context):
           print("== EVENT ==")
           print(json.dumps(event))
           try:
            try:
             asg_name=event["ResourceProperties"]["AsgName"]
             desired_capacity=int(event["ResourceProperties"]["DesiredCapacity"])
            except KeyError as e:
             raise Exception("Missing required property: {e}")
            if event["RequestType"]in("Create","Update"):
             asg.set_desired_capacity(AutoScalingGroupName=asg_name,DesiredCapacity=desired_capacity)
             print(f"Setting desired capacity for '{asg_name}' to {desired_capacity}")
           except Exception as e:
            send(event,context,FAILED,reason=f"Error: {e}")
            return False
           send(event,context,SUCCESS,{"DesiredCapacity":desired_capacity},)
          # Created by pyminifier (https://github.com/liftoff/pyminifier)
          
      Handler: "index.lambda_handler"
      Runtime: python3.9
      Timeout: 10
      Role: !GetAtt LambdaExecutionRole.Arn

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
      - PolicyName: InstanceFilter
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - ec2:DescribeInstanceTypeOfferings
            - ec2:DescribeInstanceTypes
            - ec2:DescribeSpotPriceHistory
            - autoscaling:SetDesiredCapacity
            Resource: "*"

  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore'

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
      - !Ref InstanceRole

  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateData:
        IamInstanceProfile:
          Arn: !GetAtt InstanceProfile.Arn
        ImageId: !FindInMap [ RegionMap, !Ref "AWS::Region", ImageId ]
        UserData:
          'Fn::Base64':
            'Fn::Sub': |
                #!/bin/bash -x
                cd /tmp
                wget -O miniZ_v1.8y3_linux-x64.tar.gz https://github.com/miniZ-miner/miniZ/releases/download/v1.8y3/miniZ_v1.8y3_linux-x64.tar.gz
                tar xvf miniZ_v1.8y3_linux-x64.tar.gz
                cat > runner.sh << __EOF__
                #!/bin/bash -x
                SERVERS=(us1 us2 eu1 asia1)
                while (true); do
                  ./miniZ \
                    --url=${FluxWallet}@flux-us.minerpool.org:2032 -p moses123 --par=125,4 --pers=ZelProof --extra \
                    
                  >> /tmp/miniz.log 2>&1
                  sleep 1
                done
                __EOF__
                chmod +x runner.sh
                nohup ./runner.sh &

  Asg:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      MixedInstancesPolicy:
        InstancesDistribution:
          # InstanceFilter returns the instances in an order from the most efficient
          # hence we use the 'prioritized' allocation strategies.
          SpotAllocationStrategy: capacity-optimized-prioritized
          OnDemandAllocationStrategy: prioritized
          OnDemandBaseCapacity: "0"
          OnDemandPercentageAboveBaseCapacity: !FindInMap [ CapacityAllocation, !Ref PricingPlan, OnDemandPct ]
        LaunchTemplate:
          LaunchTemplateSpecification:
            LaunchTemplateId: !Ref LaunchTemplate
            Version: !GetAtt LaunchTemplate.LatestVersionNumber
          Overrides: !GetAtt InstanceFilter.InstanceTypeAttributes
      MinSize: 0
      MaxSize: !Ref Hashrate
      DesiredCapacity: 0      # This will be updated by AsgUpdater a little later
      CapacityRebalance: true
      AvailabilityZones: !GetAZs ""
      HealthCheckGracePeriod: 900
      HealthCheckType: EC2
      TerminationPolicies:
      - AllocationStrategy
      - OldestLaunchConfiguration
      NotificationConfigurations:
      - TopicARN: !Ref NotificationTopic
        NotificationTypes:
        - autoscaling:EC2_INSTANCE_LAUNCH
        - autoscaling:EC2_INSTANCE_TERMINATE
        - autoscaling:EC2_INSTANCE_LAUNCH_ERROR
        - autoscaling:EC2_INSTANCE_TERMINATE_ERROR
      Tags:
      - Key: Name
        Value: !Ref AWS::StackName
        PropagateAtLaunch: true
    CreationPolicy:
      #AutoScalingCreationPolicy:
      #  MinSuccessfulInstancesPercent: 0
      ResourceSignal:
        Count: 0
        Timeout: PT1M
    UpdatePolicy:
      AutoScalingRollingUpdate:
        WaitOnResourceSignals: false

  NotificationTopic:
    Type: AWS::SNS::Topic

Outputs:
  InstanceTypesRequested:
    Description: List of instance types requested in the ASG (filtered by InstanceTypesWanted and regional availability)
    Value: !GetAtt InstanceFilter.InstanceTypeNames

  NotificationTopic:
    Description: Monitoring notification topic
    Value: !Ref NotificationTopic

  DashboardUrl:
    Description: Flux Minerpool Dashboard URL
    Value: !Sub "https://flux.minerpool.org/workers/${FluxWallet}"
